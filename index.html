<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Overstappen</title>

  <style>
    :root{
      --accent:#FFCC11;
      --bg:#070a0f;
      --panel:#0e1520;
      --panel2:#0c121b;
      --line:#233246;
      --text:#f3f6fb;
      --muted:rgba(243,246,251,.78);
      --muted2:rgba(243,246,251,.60);

      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 18px; /* basis groter voor leesbaarheid */
    }

    html,body{height:100%;}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    header{
      padding: 22px 22px 18px 22px;
      border-bottom: 2px solid rgba(255,204,17,.45);
      background:
        radial-gradient(1200px 300px at 20% 0%, rgba(255,204,17,.18), transparent 60%),
        linear-gradient(180deg, rgba(255,204,17,.08), transparent 70%);
    }

    h1{
      margin:0;
      font-size: 30px;
      line-height: 1.15;
      letter-spacing: .01em;
      font-weight: 900;
    }
    .subline{
      margin-top: 8px;
      font-size: 14px;
      color: var(--muted2);
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 22px;
    }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid var(--line);
      background: var(--panel);
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
    }

    thead th{
      text-align:left;
      font-size: 13px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(243,246,251,.80);
      padding: 16px 16px;
      border-bottom: 1px solid var(--line);
      background: var(--panel2);
    }

    tbody td{
      padding: 16px 16px;
      border-bottom: 1px solid rgba(35,50,70,.85);
      font-size: 20px;
      line-height: 1.2;
      vertical-align: middle;
    }
    tbody tr:last-child td{border-bottom:none;}
    tbody tr:hover{background: rgba(255,255,255,.02);}

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 10px 14px;
      border-radius: 14px;
      font-weight: 950;
      letter-spacing: .02em;
      font-variant-numeric: tabular-nums;
      min-width: 76px;
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
    }
    .badge.fallback{
      background: rgba(255,204,17,.20);
      color: #111;
      border-color: rgba(255,204,17,.45);
    }

    .dest{
      font-weight: 750;
    }

    .depart{
      font-variant-numeric: tabular-nums;
      font-weight: 950;
      white-space: nowrap;
      font-size: 22px;
    }

    .muted{
      color: var(--muted);
      font-size: 14px;
    }

    .hint{
      margin-top: 14px;
      color: var(--muted2);
      font-size: 14px;
    }
  </style>
</head>

<body>
<header>
  <h1 id="title">Overstappen aan —</h1>
  <div class="subline" id="subline">—</div>
</header>

<main>
  <table aria-label="Doorkomsten">
    <thead>
      <tr>
        <th style="width:160px;">Lijn</th>
        <th>Bestemming</th>
        <th style="width:160px;">Vertrek</th>
      </tr>
    </thead>
    <tbody id="rows">
      <tr><td colspan="3" class="muted">Laden…</td></tr>
    </tbody>
  </table>

  <div class="hint">
    Gebruik: <strong style="color:var(--accent);">…/?stopId=123456</strong> • Console bevat logging voor grouping/matches.
  </div>
</main>

<script>
  // ================= CONFIG =================
  const API_KEY = "ee23ac060f8a4038ad6d69358d85a1b0";
  const MAX_PER_HALTE = 7;     // max doorkomsten per halte/perron (per blok uit API)
  const MAX_AANTAL_API = 10;   // API parameter (mag hoger, wij knippen zelf)
  const REFRESH_MS = 15000;

  // Zet dit op false als je console clean wil
  const DEBUG = true;

  // ================= HELPERS =================
  const $ = (id) => document.getElementById(id);

  function log(...args){ if(DEBUG) console.log(...args); }

  function parseCSVLine(line){
    // eenvoudige CSV parser met quotes (voldoende voor GTFS)
    const out = [];
    let cur = "", inQ = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(ch === '"'){
        if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if(ch === "," && !inQ){
        out.push(cur);
        cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  function minutesUntil(iso){
    const t = new Date(iso).getTime();
    const now = Date.now();
    return Math.round((t - now) / 60000);
  }

  function formatMinutes(m){
    if(m <= 0) return "nu";
    return `${m}'`;
  }

  function getStopIdFromUrl(){
    const p = new URLSearchParams(location.search);
    return (p.get("stopId") || "").trim();
  }

  function getEntityFromStopId(stopId){
    const firstChar = stopId[0];
    const ent = parseInt(firstChar, 10);
    return Number.isNaN(ent) ? null : ent;
  }

  function normalizeName(s){
    // voor matching: lowercase + whitespace normalisatie
    return (s || "")
      .toLowerCase()
      .replace(/\s+/g, " ")
      .trim();
  }

  function cleanStopName(name){
    if(!name) return "";
    // knip vanaf: " perron", " opstaphalte", " afstaphalte", " quai", "," of "("
    const re = /(\s+perron\b|\s+opstaphalte\b|\s+afstaphalte\b|\s+quai\b|,|\()/i;
    const m = re.exec(name);
    const cut = m ? name.slice(0, m.index) : name;
    // extra whitespace opruimen
    return cut.replace(/\s+/g, " ").trim();
  }

  // ================= ROUTES LOOKUP =================
  // Map: prefix4 -> { shortName, color, textColor }
  let routeMap = new Map();

  async function loadRoutes(){
    const res = await fetch("./routes.txt", { cache: "no-store" });
    if(!res.ok) throw new Error(`routes.txt niet gevonden (HTTP ${res.status})`);
    const txt = await res.text();

    const lines = txt.split(/\r?\n/).filter(l => l.trim().length > 0);
    if(lines.length < 2) throw new Error("routes.txt lijkt leeg");

    const header = parseCSVLine(lines[0]).map(h => h.replace(/^"|"$/g,""));
    const idx = (name) => header.indexOf(name);

    const iRouteId = idx("route_id");
    const iShort   = idx("route_short_name");
    const iColor   = idx("route_color");
    const iTextCol = idx("route_text_color");

    if(iRouteId < 0 || iShort < 0) throw new Error("routes.txt mist route_id/route_short_name");

    const map = new Map();
    for(let li=1; li<lines.length; li++){
      const row = parseCSVLine(lines[li]);
      if(row.length !== header.length) continue;

      const routeIdRaw = (row[iRouteId] ?? "").replace(/^"|"$/g,"");
      if(routeIdRaw.length < 4) continue;

      const prefix4 = routeIdRaw.slice(0,4);
      // "eerste resultaat" wint
      if(!map.has(prefix4)){
        map.set(prefix4, {
          shortName: (row[iShort] ?? "").replace(/^"|"$/g,""),
          color: (row[iColor] ?? "").replace(/^"|"$/g,""),
          textColor: (row[iTextCol] ?? "").replace(/^"|"$/g,"")
        });
      }
    }
    routeMap = map;
    log("[routes] prefixes:", routeMap.size);
  }

  // ================= STOPS LOOKUP =================
  // stopId -> rawName
  let stopIdToName = new Map();
  // normalizedCleanName -> { displayName, stopIds[] }
  let cleanGroup = new Map();

  async function loadStops(){
    const res = await fetch("./stops.txt", { cache: "no-store" });
    if(!res.ok) throw new Error(`stops.txt niet gevonden (HTTP ${res.status})`);
    const txt = await res.text();

    const lines = txt.split(/\r?\n/).filter(l => l.trim().length > 0);
    if(lines.length < 2) throw new Error("stops.txt lijkt leeg");

    const header = parseCSVLine(lines[0]).map(h => h.replace(/^"|"$/g,""));
    const idx = (name) => header.indexOf(name);

    const iStopId = idx("stop_id");
    const iStopName = idx("stop_name");
    if(iStopId < 0 || iStopName < 0) throw new Error("stops.txt mist stop_id/stop_name");

    const idToName = new Map();
    const group = new Map();

    for(let li=1; li<lines.length; li++){
      const row = parseCSVLine(lines[li]);
      if(row.length !== header.length) continue;

      const stopId = (row[iStopId] ?? "").replace(/^"|"$/g,"").trim();
      const stopName = (row[iStopName] ?? "").replace(/^"|"$/g,"").trim();
      if(!stopId) continue;

      idToName.set(stopId, stopName);

      const cleaned = cleanStopName(stopName);
      const norm = normalizeName(cleaned);
      if(!norm) continue;

      if(!group.has(norm)) group.set(norm, { displayName: cleaned, stopIds: [] });
      group.get(norm).stopIds.push(stopId);
    }

    stopIdToName = idToName;
    cleanGroup = group;

    log("[stops] stopIdToName:", stopIdToName.size, "clean groups:", cleanGroup.size);
  }

  // ================= BUILD LIST KEY =================
  function buildHaltesLijstKey(stopIds){
    // "2_212223_2_212224"
    const parts = [];
    for(const sid of stopIds){
      const ent = getEntityFromStopId(sid);
      if(ent === null) continue;
      parts.push(`${ent}_${sid}`);
    }
    return parts.join("_");
  }

  function getRouteBadge(doorkomst){
    const entiteit = Number(doorkomst.entiteitnummer);
    const lijnnr = Number(doorkomst.lijnnummer);

    const routeKeyNum = (entiteit * 1000) + lijnnr;
    const prefix4 = String(routeKeyNum).padStart(4, "0").slice(0,4);

    const route = routeMap.get(prefix4) || null;
    const shortName = route?.shortName || String(lijnnr);

    const bg = route?.color ? `#${route.color}` : null;
    const fg = route?.textColor ? `#${route.textColor}` : null;

    return { shortName, bg, fg, prefix4 };
  }

  // ================= MAIN =================
  async function loadBoard(){
    const stopId = getStopIdFromUrl();

    if(!stopId){
      $("title").textContent = "Overstappen";
      $("subline").textContent = "Geen stopId in de URL.";
      $("rows").innerHTML = `<tr><td colspan="3" class="muted">Gebruik ?stopId=123456</td></tr>`;
      return;
    }

    const rawName = stopIdToName.get(stopId) || "";
    const cleaned = cleanStopName(rawName);
    const norm = normalizeName(cleaned);

    // Fallbacks als stopId niet in stops.txt zit
    const displayName = cleaned || "—";
    $("title").textContent = `Overstappen aan ${displayName}`;
    document.title = `Overstappen aan ${displayName}`;

    // Groep stop_ids (zelfde ingekorte naam)
    let groupStopIds = [];
    if(norm && cleanGroup.has(norm)){
      groupStopIds = cleanGroup.get(norm).stopIds.slice();
    } else {
      groupStopIds = [stopId];
    }

    // Zorg dat het originele stopId zeker mee in de groep zit
    if(!groupStopIds.includes(stopId)) groupStopIds.unshift(stopId);

    // Logging om te debuggen waarom grouping faalt
    log("[grouping] stopId:", stopId);
    log("[grouping] rawName:", rawName);
    log("[grouping] cleaned:", cleaned, "norm:", norm);
    log("[grouping] stopIds:", groupStopIds);

    $("subline").textContent = `Haltes in groep: ${groupStopIds.length}`;

    const key = buildHaltesLijstKey(groupStopIds);
    log("[api] haltes/lijst key:", key);

    if(!key){
      $("rows").innerHTML = `<tr><td colspan="3" class="muted">Geen geldige stop_ids gevonden.</td></tr>`;
      return;
    }

    const url = `https://api.delijn.be/DLKernOpenData/api/v1/haltes/lijst/${key}/real-time?maxAantalDoorkomsten=${MAX_AANTAL_API}`;
    log("[api] url:", url);

    try{
      const res = await fetch(url, {
        method: "GET",
        headers: {
          "Cache-Control": "no-cache",
          "Ocp-Apim-Subscription-Key": API_KEY
        }
      });

      if(!res.ok){
        const t = await res.text().catch(()=> "");
        throw new Error(`API fout: HTTP ${res.status} — ${t.slice(0,160)}`);
      }

      const data = await res.json();

      // Meerdere halteDoorkomsten: per halte maximaal 7 nemen, dan flatten
      const blocks = data?.halteDoorkomstenLijst?.[0]?.halteDoorkomsten || [];
      log("[api] blocks:", blocks.length);

      const all = [];
      for(const hd of blocks){
        const dks = hd?.doorkomsten || [];
        // max 7 per halte/perron
        const sliced = dks.slice(0, MAX_PER_HALTE);
        log("[api] haltenummer:", hd?.haltenummer, "doorkomsten:", dks.length, "used:", sliced.length);
        for(const d of sliced) all.push(d);
      }

      if(!all.length){
        $("rows").innerHTML = `<tr><td colspan="3" class="muted">Geen doorkomsten.</td></tr>`;
        return;
      }

      // sorteer op (realtime of dienstregeling)
      all.sort((a,b)=>{
        const ta = new Date(a["real-timeTijdstip"] || a.dienstregelingTijdstip).getTime();
        const tb = new Date(b["real-timeTijdstip"] || b.dienstregelingTijdstip).getTime();
        return ta - tb;
      });

      // render
      const rowsHtml = all.map(d => {
        const { shortName, bg, fg, prefix4 } = getRouteBadge(d);

        const badgeStyle = bg ? `background:${bg};color:${fg || "#000"};` : ``;
        const badgeClass = bg ? "badge" : "badge fallback";

        const bestemming = d.bestemming ?? "—";

        // Altijd x' — realtime indien beschikbaar, anders dienstregeling
        const iso = d["real-timeTijdstip"] || d.dienstregelingTijdstip || null;
        const vertrekTxt = iso ? formatMinutes(minutesUntil(iso)) : "—";

        // extra debug per rij (optioneel)
        if(DEBUG){
          log("[row]",
            "lijnnr", d.lijnnummer,
            "ent", d.entiteitnummer,
            "prefix4", prefix4,
            "short", shortName,
            "best", bestemming,
            "vertrek", vertrekTxt
          );
        }

        return `
          <tr>
            <td><span class="${badgeClass}" style="${badgeStyle}">${shortName}</span></td>
            <td class="dest">${bestemming}</td>
            <td class="depart">${vertrekTxt}</td>
          </tr>
        `;
      }).join("");

      $("rows").innerHTML = rowsHtml;

    } catch(err){
      console.error(err);
      $("rows").innerHTML = `<tr><td colspan="3" class="muted">Fout: ${String(err.message || err)}</td></tr>`;
    }
  }

  // ================= BOOT =================
  (async () => {
    try{
      await Promise.all([loadRoutes(), loadStops()]);
    } catch(e){
      console.error(e);
      $("title").textContent = "Overstappen";
      $("subline").textContent = "GTFS bestanden konden niet geladen worden.";
      $("rows").innerHTML = `<tr><td colspan="3" class="muted">Controleer of routes.txt en stops.txt in de root staan.</td></tr>`;
      return;
    }

    await loadBoard();
    setInterval(loadBoard, REFRESH_MS);
  })();
</script>
</body>
</html>
